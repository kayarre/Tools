import os
import numpy as np
from scipy import fftpack
import scipy.special as special

def generate_coefficents(data, N_coef=20):
    """
        take the fft of some time series data and get the meaningful part of it
        @param data, the input time series data
        @param period, the length of a period
        @param, the number of coeffcients to return,
            the minimum of the number of coefficients generated by the fft or N_Coef
    """
    data_real = np.real(data) # get the real values
    F = fftpack.fft(data_real)/len(data_real)
    F[1:] = F[1:]*2.0
    return F[:min(F.shape[0],N_coef)]


# data from http://www.mie.utoronto.ca/labs/bsl/data.html
def get_coefficients():
    """
        The fft of this data used exp(1.0j) vs exp(-1.0j) thus need conjugate
    """
    coef = [(1.0, 0), (0.179325, 0.498146), (-0.385872, 0.511875), (-0.450811, -0.329866),
        (-0.106449, -0.263848), (0.295767, -0.317235), (0.194631, 0.177449),
        (-0.0336471, 0.0964081), (-0.0444237, 0.0253163), (-0.0253872, -0.0337126),
        (0.0242532,  -0.0221089), (0.0197074, 0.00370957), (0.00928437, 0.0083496),
        (0.00165714, 0.0120435)]
    coef = np.array([complex(c[0], -c[1]) for c in coef])
    return coef


def reconstruct(coef, T=1.0, t_pts=200):
    """ Calculate flow rate with sines and cosines
    """
    t = np.linspace(0,T,t_pts)
    Q = np.zeros(t.shape)
    omega = 2.0*np.pi/T
    for idx, c in enumerate(coef):
        Q += c.real*np.cos(omega*idx*t) - c.imag*np.sin(omega*idx*t)
    return Q, t


def reconstruct_pt(coef, t, T=1.0):
    """ reconstruct the value at one point
    using sines and cosines
    """
    Q = 0.0
    omega = 2.0*np.pi/T
    for idx, c in enumerate(coef):
        Q += c.real*np.cos(omega*idx*t) - c.imag*np.sin(omega*idx*t)
    return Q


def reconstruct2(coef, T=1.0, t_pts=200):
    """Calculate flow rate with exponentials
        of the fft was exp(-1.0j) then the reconstruction is exp(1.0j)
    """
    t = np.linspace(0,T,t_pts)
    Q = np.zeros(t.size, dtype=np.complex)
    omega = 2.0*np.pi/T
    for idx, c in enumerate(coef):
        #print(c[0]*np.exp(1.0j*np.pi*idx*t/T))
        Q += (c * np.exp(1.0j*omega*idx*t))
    return Q.real, t


def reconstruct_pt2(coef, t, T=1.0):
    """ reconstruct the value at one point
    using exponentials
    """
    Q = 0.0j
    omega = 2.0*np.pi/T
    for idx, c in enumerate(coef):
        #print(c[0]*np.exp(1.0j*np.pi*idx*t/T))
        Q += (c * np.exp(1.0j*omega*idx*t))
    return Q.real


def womersley_number(rho, omega, mu, R, n=1.0):
    """Returns the womersley number alpha.
    @param R: pipe radius
    @param omega: oscillation frequency
    @param mu: viscosity
    @param rho: fluid density
    """
    return np.sqrt(n*rho*omega/mu)*R

def womersley_velocity(coef, rho, omega, mu, R, r, t):
    """Returns the analytical velocity profile  from fourier coefficients
    @param coef: fft velocity coefficients
    @param rho: density
    @param omega: frequency, 1/T
    @param mu: viscosity
    @param R: pipe radius
    @param r: radius coordinate
    @param t: time coordinate
    """
    term_1 = coef[0] * (1.0-(r/R)**2) # steady flow portion 
    term_2 = complex(0.0, 0.0j) # unsteady portion defined below
    if r < 0.0:
        r = abs(r)
    for n, c in enumerate(coef):
        if n == 0:
            continue
        alpha_n = womersley_number(rho, omega, mu, R, n)
        lambda_ = np.sqrt(1.0j**3) * alpha_n
        exp_term = np.exp(1.0j * n * omega * t)
        J_num = special.jn(0, lambda_ * r / R) / special.jn(0, lambda_)
        term_2 += c * (1.0 - J_num) * exp_term
    return term_2 + term_1

def womersley_parts(coef, rho, omega, mu, R, r, t):
    """Returns the analytical velocity profile  from fourier coefficients
    @param coef: fft velocity coefficients
    @param rho: density
    @param omega: frequency, 1/T
    @param mu: viscosity
    @param R: pipe radius
    @param r: radius coordinate
    @param t: time coordinate
    """
    term_1 = coef[0] * (1.0-(r/R)**2) # steady flow portion 
    term_2 = complex(0.0, 0.0j) # unsteady portion defined below
    if r < 0.0:
        r = abs(r)
    for n, c in enumerate(coef):
        if n == 0:
            continue
        alpha_n = womersley_number(rho, omega, mu, R, n)
        lambda_ = np.sqrt(1.0j**3) * alpha_n
        exp_term = np.exp(1.0j * n * omega * t)
        J_num = special.jn(0, lambda_ * r / R) / special.jn(0, lambda_)
        term_2 += c * (1.0 - J_num) * exp_term
        #print(special.jn(1, lambda_))
        #print(J_den)
    return term_1, term_2


# this one is the same as mean_2_quasi_shear
def scale_by_shear(coef, rho, omega, mu, R1, R2):
    """Returns the scaled shear stress coefficients
    from peak fourier coefficients
    @param coef: fft pressure coefficients
    @param rho: density
    @param omega: frequency
    @param mu: viscosity
    @param R1: pipe radius R1
    @param R2: pipe radius R2
    """
    c_new = np.zeros(coef.shape, dtype=np.complex)
    for n, c in enumerate(coef):
        if (n==0):
            c_new[0] = c*R2/R1
        else:
            # alpha_n_1 alpha_n_2 
            lambda_1 = np.sqrt(1.0j**3) * womersley_number(rho, omega, mu, R1, n)
            lambda_2 = np.sqrt(1.0j**3) * womersley_number(rho, omega, mu, R2, n)
            J1_1 = special.jn(1, lambda_1)
            J0_1 = special.jn(0, lambda_1)
            J1_2 = special.jn(1, lambda_2)
            J0_2 = special.jn(0, lambda_2)
            #print(lambda_1, lambda_2, J1_1, J0_1, J1_2, J0_2 )
            c_new[n] = c * R2/R1 * ( 1 - J0_2 / J1_2) / ( 1 - J0_1 / J1_1)
    return c_new

def scale_by_flow(coef, rho, omega, mu, R1, R2):
    """Returns the scaled mean velocity coefficients
    from mean fourier coefficients at different radius
    @param coef: fft pressure coefficients
    @param rho: density
    @param omega: frequency
    @param mu: viscosity
    @param R1: pipe radius R1
    @param R2: pipe radius R2
    """
    c_new = np.zeros(coef.shape, dtype=np.complex)
    for n, c in enumerate(coef):
        if (n==0):
            c_new[0] = c * R1**2/R2**2
        else:
            # alpha_n_1 alpha_n_2 
            lambda_1 = np.sqrt(1.0j**3) * womersley_number(rho, omega, mu, R1, n)
            lambda_2 = np.sqrt(1.0j**3) * womersley_number(rho, omega, mu, R2, n)
            J1_1 = special.jn(1, lambda_1)
            J0_1 = special.jn(0, lambda_1)
            J1_2 = special.jn(1, lambda_2)
            J0_2 = special.jn(0, lambda_2)
            #print(lambda_1, lambda_2, J1_1, J0_1, J1_2, J0_2 )
            c_new[n] = c * R1**2/R2**2 * ( 1 - 2.0/lambda_2 * J1_2 / J0_2) / ( 1 - 2.0/lambda_1 * J1_1 / J0_1)
    return c_new


def to_grayscale(im, weights = np.c_[0.2989, 0.5870, 0.1140]):
    """
    Transforms a colour image to a greyscale image by
    taking the mean of the RGB values, weighted
    by the matrix weights
    """
    tile = np.tile(weights, reps=(im.shape[0],im.shape[1],1))
    return np.sum(tile * im, axis=2)


